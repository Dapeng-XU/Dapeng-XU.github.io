\documentclass[14pt, letterpaper, UTF8, fontset=windowsnew, heading=true]{article}
\usepackage[UTF8]{ctex}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}

%opening
\title{软件工程复习笔记}
\author{徐大鹏}

\newcommand{\ul}[1]{\underline{#1}}

\begin{document}

\maketitle

软件工程大水课！一定要考好！求保佑！

\section{软件工程概述}

\subsection{复习提纲里的考点}

\begin{enumerate}
	\item SE的定义、目的、方法及作用(P2 / P16) \\
	定义是什么？方法呢？作用呢？不知道。
	\begin{itemize}
		\item 章前简介：我们的\emph{最终目标}是，生产出高质量软件，进而找到解决方案，并考虑那些对质量有影响的特性。
		\item 1.2节：要写出健壮的、易于理解和维护的并且能以最高效的方式完成工作的代码，必须具备专业软件工程师的技巧和洞察力。因此\emph{软件工程的目标}就是设计和开发高质量软件。
		\item 1.1.2节：\emph{软件工程师的角色}：软件工程师的精力集中于将计算机作为求解问题的工具，而不是研究硬件设计或者算法的理论证明。
	\end{itemize}
	
%	\item (不是考点) 开发模式(paradigm) (P4) \\
%	在1.1.1节：
%	\begin{description}
%		\item[技术] 是产生某些结果的形式化过程。
%		\item[工具] 是用更好的方式完成某件事情的设备或自动化系统。
%		\item[过程] 把工具和技术结合起来，共同生产特定产品。
%		\item[范型(paradigm)] 表示构造软件的特定方法或哲学。
%	\end{description}
%	软件工程师使用工具、技术和范型来提高\emph{软件产品的质量}。
	
	\item
	说明\textbf{错误}、\textbf{缺陷}、\textbf{失败}的含义与联系。（请举例说明）（ 6 页）（ 44 页习题 3） \\
	当人们在进行软件开发活动的过程中出错（\emph{错误}）时，就会出现\emph{故障}。
	\emph{失效}是指系统违背了它应有的行为。
	故障是系统的内部视图，是从开发人员的角度看待系统；失效是系统的外部视图，是从用户的角度。见图\ref{fig:errorfailure}。
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.91\textwidth]{f1-4.PNG}
		\caption{错误和失效}
		\label{fig:errorfailure}
	\end{figure}
	
	\item 软件质量应从哪几个方面来衡量？(P9 -- P12)
	\begin{description}
		\item[产品的质量] 用户角度：易于学习、易于使用；故障的数目少，故障类型都是次要的（次要的、主要的、灾难性的）。设计和编写代码的人员、维护该程序的人员：考虑产品的内部特性，把故障的数目和类型看做产品质量的证据。
		\item[过程的质量] 只要有活动出了差错，产品的质量就会受到影响。提出问题：What? When? Where? How?
		\item[商业环境背景下的质量] 提供的产品和服务。
	\end{description}

%	\item (不是考点) 软件系统的组成(P16) \\
%	第1.5.1节，系统的要素：
%	\begin{description}
%		\item[活动和对象] \emph{活动}是发生在系统中的某些事情，通常描述为由某个触发器引起的事件（事件驱动的），活动通过改变某一特性将一个事物转变成为另一个事物（活动的概念、活动的结果）。活动中涉及的要素称为\emph{对象}或\emph{实体}。通常，这些对象以某种方式相互联系。
%		\item[关系和系统边界] 把\emph{系统}定义为一组事物的集合：一组\ul{实体}、一组\ul{活动}、实体和活动之间\ul{关系}的描述以及系统\ul{边界}的定义。\emph{边界}就是系统包含什么和不包含什么的一个区分。
%	\end{description}

	\item 现代软件工程大致包含的几个阶段及各个阶段文档(P23--P24) \\
	1.6.2节。这个问题也是软件过程由哪几个主要部分组成的答案。
	\begin{description}
		\item[需求分析和定义] 与客户会面以确定需求，这些需求是对系统的描述。
		\item[系统设计] 系统设计告诉客户，从客户的角度看，系统会是什么样的。然后客户要对设计进行评审。当设计得到批准之后，整个系统设计将被用来生成其中单个程序的设计。
		\item[程序设计] 
		\item[编写程序]
		\item[单元测试] 链接之前作为单独的代码段进行测试。
		\item[集成测试] 将模块组合到一起，确保他们能够正确运行。
		\item[系统测试] 对整个系统的测试，用于确保起初指定的功能和交互得以实现。
		\item[系统交付] 
		\item[维护] 出现任何问题，或者需求发生变化时。
	\end{description}

%	\item 
%	(不是考点) 使现代软件工程发生变化的七个关键因素(P28--P29)
%	\\ 1.8.1节：图\ref{fig:sevenreasons}
%	\begin{figure}[h]
%		\centering
%		\includegraphics[width=0.91\textwidth]{c1-8-2.PNG}
%		\caption{使发生变化的七个关键因素}
%		\label{fig:sevenreasons}
%	\end{figure}

	\item
	什么是抽象？(P30)\\
	1.8.2节。\emph{抽象}是在某种概括层次上对问题的描述，使得我们能够集中于问题的关键方面而不会陷入细节。
	
	\item
	什么是软件过程？软件过程的重要性是什么？包含几个阶段？(P32, P45) \\ 
	软件过程的定义和重要性在第二章有相应的问题。包含哪几个阶段在上面的问题中提到过。图\ref{fig:procedure-differences}仅供参考。
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.91\textwidth]{f1-14.PNG}
		\caption{软件过程的差别}
		\label{fig:procedure-differences}
	\end{figure}
	
	\item
	什么是重用等软件工程主要概念？(P34) \\ 1.8.2节。图\ref{fig:multiplexing}
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.91\textwidth]{c1-8-2-6.PNG}
		\caption{复用}
		\label{fig:multiplexing}
	\end{figure}
	
\end{enumerate}

%\subsection{软件工程的重要性}
%第12页终于出现了一点干货：
%\begin{enumerate}
%	\item 新的观点：软件决定计算机系统的价值
%	\item 隐藏在计算机系统背后的困难
%	\begin{itemize}
%		\item 新的观点：软件决定计算机系统的价值
%		\item 
%		非编程问题，用计算机及开发环境本身无法解决。
%		例如：预算、进度、用户需求的优先级处理等等
%		问题。
%	\end{itemize}
%\end{enumerate}

\section{模型化过程和生命周期}

\subsection{提到的考点}

\begin{enumerate}
	\item 什么是软件过程？软件过程的重要性是什么？ (P45-46) \\
	2.1节。\\
	\emph{软件过程}是软件开发活动中产生某种期望结果的\ul{一系列有序任务}，涉及\ul{活动、约束和资源}。
	
	\begin{description}
		\item[重要性] 它强制活动具有\ul{一致性}和\ul{一定的结构}。当我们知道如何把事情做好而且希望其他人也能以\ul{同样的方式}做事时，这些特性就很有用。
		\item[灵活性] 当然，可以在过程模型一致的前提下，不同的开发人员或者开发团队选用不同的技术和工具来完成某个开发过程，这体现了灵活性。
	\end{description}

	PPT上的描述：
	\begin{description}
		\item[过程的重要性] \ul{一致性和结构性}可以使我们知道是否已经做好了工作，还能使别人以同样的方式做工作，因而具有相对通用性。过程有助于保持\ul{大量不同人员}开发的产品和服务之间的\ul{一致性和质量}。
	\end{description}	

	\item 瀑布模型及各阶段文档，优缺点？ (P49)\\
	\emph{瀑布模型}将开发阶段描述为从一个阶段瀑布般地转换到另一个阶段，一个开发阶段必须在另一个开发阶段开始之前完成。
	\begin{description}
		\item[优点] 在帮助开发人员布置他们需要做的工作时，瀑布模型是非常有用的。它的\ul{简单性}使得开发人员很容易向\ul{不熟悉}软件开发的客户做出解释。它\ul{明确地}说明，为了开始下一阶段的开发，那些中间产品是必需的。
		\item[缺点] (1)瀑布模型并不能反应实际的代码开发方式。实际上软件是通过\ul{大量的迭代}进行开发的。(2)文档转换有困难。
	\end{description}
	
	\item 原型的概念(P51) \\
	\emph{原型}是一个\ul{部分开发}的产品，它使\ul{客户和开发人员}能够对\ul{计划开发}的系统的相关方面进行检查，以决定它对\ul{最终产品}是否合适或恰当。
	
	\item 论述分阶段开发模型的含义, 其基本分类及特点是什么？ (56 页) \\
	2.2.6节，阶段化开发：增量和迭代。 \\
	关键概念：\emph{循环周期}、、。\\
	\emph{阶段化开发}是指，系统被设计成部分提交, 每次用户只能得到部
	分功能, 而其他部分处于开发过程中。\\
	\emph{产品系统}：用户正在使用的版本 \\
	\emph{开发系统}：准备代替现有产品系统
	的下一个版本 \\
	基本分类：
	\begin{description}
		\item[增量开发] 系统需求按照功能分成若干子系统，开始建造的版本
		是规模小的、部分功能的系统，后续版本添加包含新
		功能的子系统，最后版本是包含全部功能的子系统集。
		\item[迭代开发] 系统开始就提供了整体功能框架，后续版本陆续增强
		各个子系统，最后版本使各个子系统的功能达到最强。
	\end{description}
	
	\item 螺旋模型四个象限的任务及四重循环的含义？ (P58) \\
	\emph{螺旋模型}将开发活动与风险管理结合起来, 以降低和控制风险。
	四个象限：计划，确定目标、可选方案和约束，评估可选方案和风险，开发与测试。 \\
	四次迭代：操作概念、软件需求、软件设计、系统测试与交付。\\
	\\ \textbf{要看习题：P80--81 页 习题 2， 3。}
	
%	// 在所有的软件开发过程模型中，你认为哪些过程给予你最大的灵活性以应对需求的变更？(81 页习题 11)

	\item 什么是UP，RUP? \\
	\emph{统一软件开发过程}（英语：Rational Unified Process，缩写为RUP），一种软件工程方法，为迭代式软件开发流程。最早由Rational Software公司开发，因此冠上公司名称。因此名字上可以直接叫做\emph{统一过程}(UP)；Rational是公司名，也写作RUP。
	\begin{description}
		\item[统一过程] 用例驱动的、以基本架构为中心的、迭代式和增量性的软件开发过程框架。
	\end{description}
	统一过程将重复一系列\emph{生命周期}，这些生命期构成了
	一个系统的寿命。每个生命周期都以向客户推出一个产品
	版本而结束。统一过程的每个周期包括\emph{四个阶段}，
	\begin{description}
		\item[构思阶段(inception phase)] 包括用户沟通和计划活动两个方面，强调定义和细化用例，并将其作为主要模型。
		\item[细化阶段(elaboration phase)] 包括用户沟通和建模活动，重点是创建分析和设计模型，强调类的定义和体系结构的表示。
		\item[构建阶段(construction phase)] 将设计转化为实现，并进行集成和测试。
		\item[移交阶段(transition phase)] 将产品发布给用户进行测试评价，并收集用户的意见，之后再次进行迭代修改产品使之完善。
	\end{description}
	每个阶段又可以进一步划分为多次迭代。
	见图\ref{fig:developmentiterative}。\\
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.91\textwidth]{Development-iterative.png}
		\caption{统一过程}
		\label{fig:developmentiterative}
	\end{figure}
	统一过程（UP）定义了下列三个支持\emph{工序}(discipline)。（感觉看看就行）
	\begin{enumerate}
		\item 配置变更管理工序，用来管理系统和需求变更的配置。
		\item 项目管理工序，用来管理项目。
		\item 环境配置工序，用来配置项目的环境，包括所涉及到的过程和工具。
	\end{enumerate}
	统一过程定义了下列六个核心工序（这个和一般过程相似）
	\begin{enumerate}
		\item 业务模型工序，通过业务模型获取相关知识以理解需要系统自动完成的业务。
		\item 需求工序，通过用例模型获取相关知识以理解自动完成业务的系统需求。
		\item 分析设计工序，通过分析/设计模型以分析需求，设计系统结构。
		\item 实现工序，基于实现模型实现系统。
		\item 测试工序，通过测试模型进行针对需求的系统测试。
		\item 部署工序，通过部署模型部署系统。
	\end{enumerate}

	进化式迭代开发（Iterative development）
	\begin{enumerate}
		\item 迭代开发是统一过程的关键实践
		\item 开发被组织成一系列固定的短期小项目
		\item 每次迭代都产生经过测试、集成并可执行的局部系统
		\item 每次迭代都具有各自的需求分析、设计、实现和测试
		\item 随着时间和一次次迭代，系统增量式完善
	\end{enumerate}

\end{enumerate}


\section{计划和管理项目}

\subsection{复习提纲里的考点}

\begin{enumerate}
	\item 什么是项目进度？活动？里程碑？(83页)
	\begin{description}
		\item[项目进度] 通过列举项目的各个阶段，把每个阶段分解成\emph{离散的任务或活动}，来描述特定项目的软件开发周期。
		\item[活动] 是项目的一部分，在\emph{一段时间}内发生。
		\item[里程碑] 是活动完成的\emph{时刻}。
	\end{description}

	\item 如何计算软件项目活动图的关键路径？冗余时间？最早和最迟开始时间(习题 2, 3) (课堂习题讲解)\\
	关键路径就是最长路径，即每一个节点的时差都为零的路径。冗余时间也就是时差，满足
	$$\text{时差} = \text{可用时间} - \text{真实时间} = \text{最晚开始时间} - \text{最早开始时间}$$
	计算上，要先求出最长路径，然后沿最长路径回溯，找到每一个活动的最早开始时间和最晚开始时间，然后求出每一个活动的时差。
	
	\item 软件团队人员应该具备的能力是什么？(96 页)\\
	3.2.1节。见图\ref{fig:personalability}。
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.91\textwidth]{c3-2-1.PNG}
		\caption{团队人员应该具备的能力}
		\label{fig:personalability}
	\end{figure}
	
	\item 软件项目组织的基本结构？(101 页) \\
	主程序员负责制和忘我方法。根据实际情况可以结合这两种极端情况。主程序员负责制的组织结构如何？忘我方法适于那些情况？他们的对比？（对比见图\ref{fig:groupstructure}）
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.91\textwidth]{f3-5.PNG}
		\caption{组织结构的对比}
		\label{fig:groupstructure}
	\end{figure}
	
%	\item // 专家估算法的大致含义？(106 页)，算式估算法的大致含义？(108 页) \\
%	略。
	
	\item 试述COCOMO模型的三个阶段基本工作原理或含义。(111 页) \\
	3.3.2节。见图\ref{fig:cocomo}
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.91\textwidth]{c3-3-2.PNG}
		\caption{COCOMO模型的三个阶段}
		\label{fig:cocomo}
	\end{figure}
	
	\item 什么是软件风险？主要风险管理活动？有几种降低风险的策略？(P119, P122) \\
	易。
	
	\item 找出图3.23和图3.24(P139)的关键路径。\\
	\textbf{章末必做练习题}。
\end{enumerate}

\section{获取需求}

\subsection{提到的考点}

\begin{enumerate}
	\item 需求的含义是什么?(143 页) \\
	需求就是对期望的行为的表达。需求指定客户想要什么行为，而不是如何实现这些行为。
	
	\item 需求作为一个工程，其确定需求的过程是什么？(144 页 图 4.1) \\图\ref{fig:collectrequirements}
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.91\textwidth]{f4-1.PNG}
		\caption{获取需求的过程}
		\label{fig:collectrequirements}
	\end{figure}

	\item 举例说明获取需求时，若有冲突发生时，如何考虑根据优先级进行需求分类。(152 页) \\ 4.3.1节。\\
	一般可以分为三类：必需的、值得要的、可选的。
	
%	\item // 如何使需求变得可测试？(151-152 页, sidebar4.4)

	\item 需求文档分为哪两类？(153 页) \\ 4.3.2节。\\
	\begin{description}
		\item[需求定义] 是客户想要的每一件事情的完整列表。
		\item[需求规格说明] 将需求重新陈述为关于要构建的系统将如何运转的规格说明。
	\end{description}
	
	\item 什么是功能性需求和非功能性需求/质量需求？设计约束？过程约束？ (149 页)
	\\ 4.3节开头。 \\
	\emph{功能需求}：描述系统内部功能或系统与外部环境的交互作用，涉及系统
	输入应对，实体状态变化，输出结果，设计约束与过程约束等。
	\\ \emph{非功能需求}或\emph{质量需求}：描述软件方案必须具备的某些质量特征。
	\\ \emph{设计约束}：是已经做出的决策或者限制问题解决方案集的设计决策。物理环境：对环境或设备的限制等（安装及环境要求等）
	接口：涉及输入输出的限制或约束条件. (输入格式预定等)   
	用户：使用者的基本情况（限定几种类型的用户）
	\\ \emph{过程约束}：是对于构建系统的技术和资源的限制。资源 ：材料、人员技能或其它。
	文档 ：类型、数量或其它。（涉及其针对性及要求等）
	标准 ：……
	其他 ：什么原因会导致从工资单列表中删除某雇员？
	
	
%	\item // 需求的特性？(正确性、一致性、完整性)(155 页)

	\item 知道DFD图的构成及画法(172 页) \\ 4.5.8节
	
	\item 在需求原型化方面，什么是抛弃型原型？什么是演化型原型？(192--193 页) \\
	4.7节末尾。
	
%	\item // 用DFD图简单描述ATM机的工作原理(主要功能和数据流)(220 页习题 7)

\end{enumerate}

\section{设计体系结构和设计模块}

\begin{enumerate}
	\item 什么是软件体系结构？设计模式？设计公约？设计？概念设计？技术设计？(223-224
	页) \\
	5.1节开头，5.1.1节。
	\begin{description}
		\item[体系结构] 一种软件解决方案，用于解释如何将系统分解为单元，以及单元如何相互关联，还包括这些单元的所有外部特性。
		\item[设计模式] 是一套被反复使用的（多数人知晓并经过分类编目的）代码设计经验的总结，使用设计模式目的是为了可重用代码、让代码更容易被他人理解并且保证软件质量。
		\item[设计公约] 一系列设计决策和建议的集合，用于提高系统某方面的设计质量。
		\item[设计] 是一种创造性过程，它考虑如何实现所有的客户需求。设计所产生的计划也称为设计。
		\item[概念设计] 告诉客户设计出的系统可以做什么（软件的体系结构和功能，更接近于系统设计）
		\item[技术设计] 告诉程序员设计出的系统如何做什么（软件功能和接口的实现方法，也是程序员的参考文档，更接近于程序设计）
	\end{description}
	
	\item 软件设计过程模型的几个阶段？ \\
	跟第四章第二个提到的考点差不多。图\ref{fig:archtechturedev}
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.91\textwidth]{f5-4.PNG}
		\caption{软件体系结构开发过程}
		\label{fig:archtechturedev}
	\end{figure}
	
%	\item // 三种设计层次极其关系？(229 页) \\ 略。
	
	\item 什么是模块化？什么是抽象？(238 页) \\
	6.2.1节和6.2.5节。
	
	\item 论述设计用户界面应考虑的问题。(242 页) \\
	6.6.3节。可以试着从Who? What? When? Where? How? 的角度去考虑，一共6点。
	
	\item 耦合与内聚的概念及各个层次划分？(291---301 页) \\
	6.2.1节。
	\begin{description}
		\item[耦合度] 模块之间的依赖程度的衡量。
			\begin{description}
				\item[内容耦合] 一个模块修改了另一个模块的内部数据项、代码，或者一个模块内的分支转移到另一个模块。
				\item[公共耦合] 从公共数据区存储区来访问数据。所有访问过该数据的模块都会受到影响。
				\item[控制耦合] 一个模块通过传递参数或返回代码来控制另外一个模块的活动。
				\item[标记耦合] 使用一个复杂的数据结构来从一个模块到另一个模块传递信息。
				\item[数据耦合] 两个模块之间有信息传递，但传送的只是数据值，而不是结构数据。
				\item[非耦合] 完全没有耦合。
			\end{description}
		\item[内聚度] 模块的内部元素（数据、功能、内部模块等）的粘合程度。
			\begin{description}
				\item[巧合内聚] 模块的各个部分互不相关。只是由于为了方便或者偶然的原因，不相关的功能、进程或数据处于同一个模块中。
				\item[逻辑内聚] 模块的各个部分只通过代码的逻辑结构相关联。
				\item[时间性内聚] 部件各部分要求在同一时间
				完成。
				\item[过程性内聚] 各部分有特定次序。
				\item[通信内聚] 各个部分访问共享数据。
				\item[功能内聚] 在一个模块中包含了所有必需的元素，并且每一个处理元素对于执行单个功能来说是都是必需的。
				\item[信息内聚] 在功能内聚的基础上，将其调整为数据抽象化和基于对象的设计。
			\end{description}
	\end{description}
	
	\item 举例说明耦合与内聚的基本分类。 以及各个分类的含义与特征(284 页习题 4， 5) \\
	\textbf{章末必做练习题}。

%	\item // 什么是面向对象？(286 页) OO 有几个基本特征？ 如何使用高级语言实现这些基本特征？ 了解并使用高级语言的 OO 基本编程方法和技巧。(286-291) \\
%	略。
%
%	\item 什么是设计模式？ \\
%	见设计体系结构。
	
	\item 面向对象设计的基本原则？
	\begin{description}
		\item[单一职责原则] 一个类只负责一个功能领域中的相应职责。
		\item[重用原则] 
		\item[开闭原则] 
		\item[替换原则] 
		\item[依赖倒置原则] 
		\item[接口隔离原则] 
		\item[德米特法则] 一个软件实体应当尽可能少地与其他实体发生相互作用。(例如，在两个或多个组件之间引入一个中间类，将网状结构转变为中心式结构，避免多个组件之间的直接交互)
	\end{description}
	
	\item 面向对象开发有何优势？(291 页)
	\begin{enumerate}
		\item 语言的一致性。使用相同语义的概念来描述问题和解决方案：类，对象，接口，方法，属性，行为。
		\item 过程的一致性。从需求分析、顶层设计、底层设计、编码到测试，所有的过程都使用相同语义的概念。
	\end{enumerate}
	
	\item 面向对象开发过程有几个步骤？(292 页)
	\begin{enumerate}
		\item 面向对象需求分析
		\item 面向对象顶层设计
		\item 面向对象底层设计
		\item 面向对象编程
		\item 面向对象测试
	\end{enumerate}
	
	\item 熟悉用例图的组成和画法，用例的几个要素的含义，掌握用例图的实例解析方法(294页)
	
	\item 用例图、类图等对面向对象的项目开发的意义是什么？
	
	\item 熟悉类图中各个类之间的基本关系分类(303-305) \\
	关联、组合、聚合、泛化、依赖、导航。
	
	\item 熟悉类图等的组成和画法(300-308 页)
	
	\item 知道 UML 其他图示结构的基本用途。
	
\end{enumerate}

\section{编写程序}

\subsection{提到的考点}

\begin{enumerate}
%	//为什么说编码工作是纷繁复杂甚至令人气馁？(337 页)
%	//一般性的编程原则应该从哪三个方面考虑？(340-344 页)
%	//论述编码阶段实现某种算法时所涉及的问题。(342 页)
	\item 在编写程序内部文档时，除了HCB外，还应添加什么注释信息？(352-354 页) \\
	7.3.1节。
	
	\item 什么是极限编程(XP)? 以及结对编程？ (357 页)
	7.4.2、7.4.3节。
	
\end{enumerate}

\section{测试程序}

\subsection{提到的考点}

\begin{enumerate}
%	// 产生软件缺陷的原因？(365 页)
%	// 将软件缺陷进行分类的理由？(367 页)

	\item 几种主要的缺陷类型？(367-368 页)
	\begin{description}
		\item[算法缺陷] 算法的某些处理步骤或逻辑有问题，以至
		于软件部件对给定的输入数据无法产生正
		确的输出。
		\item[计算和精度缺陷] 算法或公式在编程实现
		时出现错误或最终结果达不到精度要求。
		\item[文档缺陷] 文档与程序实际做的事情不一致。
		\item[过载缺陷] 当填充数据结构时如果超过了他们规定的能力。
		\item[能力缺陷] 系统活动达到指定的极限时，系统性能会变得不可接受。
		\item[时序性缺陷] 在实时系统中，几个同时执行的或按仔细定义的顺序执行的进程出现混乱。
		\item[性能缺陷] 系统不能以需求规定的速度执行。（同能力缺陷的区别：
		这里指正常条件下性
		能需求不能满足）
		\item[恢复性缺陷] 系统不能从失效中恢复。
		\item[硬件和系统软件缺陷] 提供的硬件和系统软件没有按照文档中的操作条件和步骤运行。
		\item[标准和过程缺陷] 代码没有遵循组织机构的标准和过程。
	\end{description}
	
	\item 什么是正交缺陷分类？(369 页) \\
	被分类的任何一项缺陷都只属于一个类别，那么这种缺陷分类方案是正交的。
	
	\item 测试的各个阶段及其任务？(372 页图 8.3) \\
	8.2.1节。	
	
%	// 测试的态度问题？(为什么要独立设置测试团队？)(373 页)

	\item 掌握测试的方法---黑盒、白盒的概念？(374) \\
	8.2.4节。
	
	\item 什么是单元测试？什么是走查和检查？(376 页) \\
	单元测试的概念：8.2.1节。 \\
	代码走查和代码审查：8.3.1节。
	
	\item 黑盒白盒方法各自的分类？各种覆盖方法等。测试用例的设计和给出方法(课件和补充课件) \\
	黑盒测试方法：
	\begin{description}
		\item[等价分类法] 每一个
		测试用例都代表了一类与它等价的其它例子。如果用这个例子未
		能发现程序的错误，则与它等价的其它例子一般也不会发现程序
		的错误。
		\item[边界值分析法] 在等价分类法中，代表一个类的测试数据可以在这个类的允
		许范围内任意选择。但如果把测试值选在等价类的边界上，往住
		有更好的效果，这就是边界值分析法的主要思想。边界值分析也适用于考察程序的\emph{输出值边界}。 
		\item[错误猜测法] 所谓猜错， 就是猜测被测程序中哪些地方容易出错，并据此设
		计测试用例。如果说等价法和边界值法均有线索可寻，则猜错法
		将更多地依赖于测试人员的直觉与经验。所以在通常情况下，这
		种方法仅用作辅助手段，即首先用其它方法设计测试用例，再用
		猜错法补充一些例子。
		\item[因果图法] 因果图法是借助图形来设计测试用例的一种系统方法，特别适
		用于被测程序具有多种输入条件，程序的输出又依赖于输入条件
		的各种组合的情况。
	\end{description}
	白盒测试方法：
	\begin{description}
		\item[逻辑覆盖法] 逻辑覆盖是一组覆盖方法的总称。按照由低到高对程序逻辑的覆盖程度，又可区分为以下几种覆盖：
		\begin{description}
			\item[语句覆盖] 使被测程序的每条语句至少执行一次
			\item[判定覆盖] 使被测程序的每一分支至少执行一次，故又称
			分支覆盖
			\item[条件覆盖] 要求判定中的每个条件均按“真”、“假”两
			种结果至少执行一次
		\end{description}
	
		\item[路径测试] 基于程序图设计的一种白盒测试方法。程序图本质上是一种简化了的流程图，它保持了控制流的全部轨迹，包括了所有的判定结点，但由于舍弃了许多细节，使画面远比流程图为简洁。覆盖标准如下：
		\begin{description}
			\item[结点覆盖] 程序的测试路径至少经过程序图中每个结点一次，相当于逻辑覆盖法中的语句覆盖。
			\item[边覆盖] 程序的测试路径至少经过程序图中的每条边一次，它相当于逻辑覆盖法中的判定覆盖。
		\end{description}
		同时满足上述两种覆盖的覆盖称为完全覆盖。
		
	\end{description}

	\item 如何面对一个命题，设计和给出测试用例的问题。(课件)---课堂练习的测试题目和讲解内容
	
	\item 集成测试及其主要方法的分类？(390-392)(驱动，桩的概念) \\
	8.4节。
	
%	// 传统测试和 OO 测试有何不同？ OO 测试有何困难？(398-399 页)
%	// 测试计划涉及的几个步骤？(400 页) (了解)
\end{enumerate}

\section{测试系统}

\subsection{提到的考点}

\begin{enumerate}
	\item 系统测试的主要步骤及各自含义？(420 页, 图 9.2) \\
	见上一章。
	
	\item 什么是系统配置？软件配置管理？
%	// 基线？
	(423 页)(或见课件) \\
	9.1节。
	
%	// 什么是回归测试？(425 页)

	\item 功能测试的含义极其作用？(430 页) \\
	9.2节。
	
	\item 功能测试的基本指导原则？ (431) \\
	9.2节。
	
	\item 性能测试的含义与作用？(436 页) \\
	9.3节。
	
	\item 性能测试的主要分类？(436 页) \\
	9.3节。
	
%	// 什么是可靠性、可用性和可维护性？(438 页)

	\item 确认测试, 确认测试分类？(基准测试和引导测试)(447-448 页) \\
	9.5节。
	
	\item 什么是$\alpha$测试？$\beta$测试？(448 页) \\
	9.5节。
	
%	// 什么是安装测试？(450 页)

\end{enumerate}

\end{document}
